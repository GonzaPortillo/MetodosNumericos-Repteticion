[ <- Regresar](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/tree/main)

# M√©todos de Soluci√≥n de Ecuaciones

# Introducci√≥n

Los **m√©todos de soluci√≥n de ecuaciones** son t√©cnicas num√©ricas utilizadas para encontrar los valores de las variables que satisfacen una ecuaci√≥n dada, es decir, los **valores que hacen que una funci√≥n se anule** (ra√≠ces de la funci√≥n). Estos m√©todos resultan √∫tiles cuando no es posible resolver una ecuaci√≥n de forma anal√≠tica o exacta. Dependiendo del tipo de funci√≥n y del comportamiento de la ra√≠z, se pueden aplicar distintos enfoques para obtener una soluci√≥n aproximada con un margen de error aceptable.

En este proyecto se abordan los siguientes m√©todos num√©ricos para encontrar ra√≠ces de funciones:

- **Bisecci√≥n**: M√©todo que divide un intervalo donde la funci√≥n cambia de signo, asegurando la presencia de una ra√≠z, y reduce el intervalo hasta alcanzar la precisi√≥n deseada.

- **Regla Falsa (Falsa Posici√≥n)**: Utiliza una interpolaci√≥n lineal entre los extremos del intervalo para estimar la ra√≠z, permitiendo una convergencia m√°s r√°pida que la bisecci√≥n en ciertos casos.

- **Secante**: Se basa en dos aproximaciones sucesivas y construye una l√≠nea secante para encontrar nuevas aproximaciones. Generalmente converge m√°s r√°pido, pero es menos estable.

- **Punto Fijo**: Reescribe la ecuaci√≥n en la forma \( x = g(x) \) y aplica iteraciones sucesivas para encontrar la ra√≠z, siempre que se cumplan ciertas condiciones de convergencia.

- **Newton-Raphson**: M√©todo muy eficiente que requiere la derivada de la funci√≥n. A partir de una aproximaci√≥n inicial, utiliza la pendiente de la tangente para aproximarse r√°pidamente a la ra√≠z.

Cada uno de estos m√©todos tiene ventajas y desventajas, y su uso depender√° del tipo de funci√≥n y la informaci√≥n disponible.

## Algoritmos

### Biseccion

1. Definir la funci√≥n ( f(x) ) y los extremos del intervalo ([a, b]) tal que ( f(a) \cdot f(b) < 0 ).
2. Calcular el punto medio ( c = \frac{a + b}{2} ).
3. Evaluar ( f(c) ). Si ( f(c) = 0 ) o el intervalo es suficientemente peque√±o (criterio de convergencia), entonces ( c ) es la ra√≠z. Si ( f(a) \cdot f(c) < 0 ), entonces la ra√≠z est√° en el intervalo ([a, c]). De lo contrario, la ra√≠z est√° en ([c, b]).
4. Repetir el proceso con el nuevo intervalo hasta que se cumpla el criterio de convergencia.

### Regla falsa 

1. Definir f(x).
2. Definir los intervalos [a,b].
3. Defiinr el umbral.
4. Calcular el punto de intersecci√≥n ùëê de la l√≠nea que une (af(a) y (b,f(b)).
5. Evaluar f(c).
6. Repetir los pasos anteriores hasta que se cumpla la condici√≥n de parada.

### Secante

1. Definir f(x).
2. Definir dos aproximaciones iniciales X0 y X1.
3. Definir el umbral de tolerancia.
4. Para i=1 hasta maxIter.
5. Calcular Xi+1 usando la formula.
6. Retornar Xi+1 como la ra√≠z aproximada si se ha alcanzado la tolerancia, o el valor m√°s cercano despu√©s de maxIter iteraciones.

### Newton Raphson

1. Definir la funcion f(x) y su derivada
2. Elegir valor inicial de x0
3. Fija la tolerancia para el error aceptable y un numero maximo de iteraciones

- En cada iteracion:

1. Calcular f(xn)
2. Calcular f'(xn)
3. Si f'(xn) = 0 se detiene debido a que no se puede continuar
4. Calcular una nueva aproximacion
5. Calcular el error
6. Si el error es menor que la tolerancia se devuelve 

### Punto fijo

1. 
## Pseudocodigos

### Biseccion

    Funci√≥n f(x):
      Retornar x^3 - x - 2

    Funci√≥n Biseccion(a, b, tolerancia, maxIteraciones):
      Si f(a) * f(b) ‚â• 0:
        Mostrar "El m√©todo de bisecci√≥n no se puede aplicar"
        Retornar NaN

      Repetir hasta maxIteraciones:
        c ‚Üê (a + b) / 2

        Si f(c) == 0 √≥ (b - a) / 2 < tolerancia:
            Retornar c

        Si f(c) * f(a) < 0:
            b ‚Üê c
        Sino:
            a ‚Üê c

    Retornar c

### Regla falsa

    Funci√≥n f(x):
        Retornar x^2 - 4

    Funci√≥n ReglaFalsa(a, b, tolerancia, maxIteraciones):
        fa ‚Üê f(a)
        fb ‚Üê f(b)

        Si fa * fb > 0:
            Mostrar "La funci√≥n no cambia de signo en el intervalo"
            Retornar NaN

        Repetir hasta maxIteraciones:
            c ‚Üê b - fb * (b - a) / (fb - fa)
            fc ‚Üê f(c)

            Si |fc| < tolerancia:
                Mostrar "Ra√≠z encontrada: c"
                Retornar c

            Si fa * fc < 0:
                b ‚Üê c
                fb ‚Üê fc
            Sino:
                a ‚Üê c
                fa ‚Üê fc

        Mostrar "No se encontr√≥ la ra√≠z despu√©s de maxIteraciones iteraciones"
        Retornar c

### Secante

    Funci√≥n f(x):
        Retornar x^3 - x^2 + 2

    Funci√≥n MetodoSecante(x0, x1, tolerancia, maxIteraciones):
        f0 ‚Üê f(x0)
        f1 ‚Üê f(x1)
        iteraciones ‚Üê 0

        Mientras |f1| > tolerancia y iteraciones < maxIteraciones:
            x2 ‚Üê x1 - f1 * (x1 - x0) / (f1 - f0)
            x0 ‚Üê x1
            f0 ‚Üê f1
            x1 ‚Üê x2
            f1 ‚Üê f(x1)
            iteraciones ‚Üê iteraciones + 1

        Si iteraciones ‚â• maxIteraciones:
            Mostrar "El m√©todo no convergi√≥ en maxIteraciones iteraciones"

        Retornar x2

### Newton-Raphson

    Funci√≥n f(x):
        Retornar f(x)   // Por ejemplo: x^3 - x - 2

    Funci√≥n fPrima(x):
        Retornar derivada de f(x)   // Por ejemplo: 3x^2 - 1

    Funci√≥n NewtonRaphson(x0, tolerancia, maxIteraciones):
        iter ‚Üê 0

        Repetir mientras iter < maxIteraciones:
            fx ‚Üê f(x0)
            fpx ‚Üê fPrima(x0)

            Si fpx == 0:
                Mostrar "Derivada cero. M√©todo fall√≥."
                Retornar NaN

            x1 ‚Üê x0 - fx / fpx

            Si |x1 - x0| < tolerancia:
                Retornar x1

            x0 ‚Üê x1
            iter ‚Üê iter + 1

        Mostrar "No se encontr√≥ la ra√≠z en el n√∫mero m√°ximo de iteraciones"
        Retornar x1


### Punto fijo

    Funci√≥n g(x):
        Retornar alguna funci√≥n equivalente a x = g(x)
        (Ejemplo: g(x) = sqrt(x + 2) si f(x) = x^2 - x - 2)

    Funci√≥n PuntoFijo(x0, tolerancia, maxIteraciones):
        iter ‚Üê 0

        Repetir mientras iter < maxIteraciones:
            x1 ‚Üê g(x0)

            Si |x1 - x0| < tolerancia:
                Retornar x1

            x0 ‚Üê x1
            iter ‚Üê iter + 1

        Mostrar "No se encontr√≥ la ra√≠z en el n√∫mero m√°ximo de iteraciones"
        Retornar x1

## Casos de prueba

### Biseccion

### Regla falsa

### Secante

### Newton-Raphson

### Punto fijo

## Ejemplos en codigo Java
### Biseccion

1. [Ejemplo 1](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Biseccion/Ejemplo1.java)
2. [Ejemplo 2](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Biseccion/Ejemplo2.java)
3. [Ejemplo 3](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Biseccion/Ejemplo3.java)
4. [Ejemplo 4](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Biseccion/Ejemplo4.java)
5. [Ejemplo 5](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Biseccion/Ejemplo5.java)

### Secante

1. [Ejemplo 1](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Secante/Ejemplo1.java)
2. [Ejemplo 2](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Secante/Ejemplo2.java)
3. [Ejemplo 3](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Secante/Ejemplo3.java)
4. [Ejemplo 4](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Secante/Ejemplo4.java)
5. [Ejemplo 5](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Secante/Ejemplo5.java)

### Regla falsa

1. [Ejemplo 1](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Regla%20Falsa/Ejemplo_1.java)
2. [Ejemplo 2](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Regla%20Falsa/Ejemplo_2.java)
3. [Ejemplo 3](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Regla%20Falsa/Ejemplo_3.java)
4. [Ejemplo 4](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Regla%20Falsa/Ejemplo_4.java)
5. [Ejemplo 5](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Regla%20Falsa/Ejemplo_5.java)

### Newton Raphson

1. [Ejemplo 1](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Newtom%20Raphson/Ejemplo_1.java)
2. [Ejemplo 2](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Newtom%20Raphson/Ejemplo_2.java)
3. [Ejemplo 3](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Newtom%20Raphson/Ejemplo_3.java)
4. [Ejemplo 4](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Newtom%20Raphson/Ejemplo_4.java)
5. [Ejemplo 5](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Newtom%20Raphson/Ejemplo_5.java)

### Punto Fijo

1. [Ejemplo 1](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Punto%20fijo/Ejemplo1.java)
2. [Ejemplo 2](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Punto%20fijo/Ejemplo2.java)
3. [Ejemplo 3](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Punto%20fijo/Ejemplo3.java)
4. [Ejemplo 4](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Punto%20fijo/Ejemplo4.java)
5. [Ejemplo 5](https://github.com/GonzaPortillo/MetodosNumericos-Repteticion/blob/main/Tema2/Punto%20fijo/Ejemplo5.java)
6. 


## M√©todos Num√©ricos para Encontrar Ra√≠ces

---

## M√©todo de Bisecci√≥n

### Algoritmo

1. Definir la funci√≥n \( f(x) \) y los extremos del intervalo \([a, b]\) tal que \( f(a) \cdot f(b) < 0 \).
2. Calcular el punto medio \( c = \frac{a + b}{2} \).
3. Evaluar \( f(c) \). Si \( f(c) = 0 \) o el intervalo es suficientemente peque√±o, \( c \) es la ra√≠z.
4. Si \( f(a) \cdot f(c) < 0 \), la ra√≠z est√° en \([a, c]\); de lo contrario, en \([c, b]\).
5. Repetir hasta cumplir el criterio de convergencia.

### Pseudoc√≥digo

```plaintext
Funci√≥n f(x):
  Retornar x^3 - x - 2

Funci√≥n Biseccion(a, b, tolerancia, maxIteraciones):
  Si f(a) * f(b) ‚â• 0:
    Mostrar "El m√©todo de bisecci√≥n no se puede aplicar"
    Retornar NaN

  Repetir hasta maxIteraciones:
    c ‚Üê (a + b) / 2
    Si f(c) == 0 √≥ (b - a)/2 < tolerancia:
      Retornar c

    Si f(c) * f(a) < 0:
      b ‚Üê c
    Sino:
      a ‚Üê c

  Retornar c

 
